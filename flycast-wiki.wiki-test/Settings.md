# Settings...what settings?
This page will guide you through all the settings avaliable in Flycast, explaining the most possible out of each one in what it does and what can they can be used for. It will go through each tab on the Settings menu of flycast.

# General 
![](https://github.com/TheArcadeStriker/flycast-wiki/blob/master/screenshots/image.png)

* **Language**: Sets the language to be used on the Dreamcast BIOS.
* **Broadcast**: Sets the video broadcast setting for non-VGA modes. Visually, it doesn't cause any effects.
* **Region**: Set console region to Japan, USA, Europe or Other. If playing an NAOMI/AW game, the Other setting can default to Korea or something else.
* **Cable**: The video connection type to be emulated, either VGA, RGB Component, or TV Composite. Visually, it doesn't cause any effects. It is recommended, though, to use TV Composite for compatibility reasons.
* **Content Location**: Shows the folders added to be checked looking for ROMs. Can also add more with the 'Add' button.
* **Home Directory**: Folder where flycast saves the VMU files, and where it searches for the data folder with the BIOS files. By default, its set to the flycast emulator folder.
* **Hide Legacy Naomi Roms**: Hides .bin, .dat and .lst files from the game list. This refers to certain NAOMI games that are in .dat/.bin (decrypted) + .lst format, which used to be necessary for NullDC NAOMI. While Flycast also supports these, it is considered to be superseded by support for standard MAME ROMs.
* **Automatic State (Load/Save)**: Automatically creates a save state of the currently running game after exiting. This automatic state will get loaded when you open the game again if the Auto Load option is enabled.

# Video
These are your graphics settings. Tweaking these can be helpful from improving performance.

## Transparent Sorting
* **Per Triangle**: Default option, highest balance between accuracy and speed. There might be some few texture/sorting glitches depending of the game but it is the fastest option without any clear consequences.
* **Per Strip**: The fastest option available, though it can definitely cause some graphical/sorting issues depending of the game (for example, decals in Daytona USA).
* **Per Pixel**: The slowest but most accurate option available, ensuring that there are no possible sorting errors. However, it might appear as broken depending of your GPU. If you are running a MALI gpu, their drives for Per Pixel vulkan sorting is non existent AND well known for many years, but we still have no fix on their end. Adreno GPU is VERY hit and miss, but use custom drivers if needed.

## Rendering Options
### Widescreen 
*Flycast has 3 built in ways that can take you 4:3 AR game, and make it full Widescreen (16:9 or larger) to fill up the whole screen. Remember, when the Dreamcast was around (99-01) Widescreen TVs were not really a thing yet. *SOME* games came with widescreen support built in, and allowed you the option to change the way the graphics were rendered for 4:3 and 16:9 screens.*

* * **Widescreen**:  This is a feature built in to Flycast to draw geometry outside of the normal 4:3 aspect ratio.  This "Brute Forces" widescreen and in a good chunk of games, this works perfect, or close enough to perfect that you do not notice much, if anything wrong. A good handful of games that work with this settings, you end up with clipping. This is when the textures load in and out in that new area being drawn in the edges of the screen. Back in the days of the Dreamcast, 16:9 was not big yet, or the hardware limitations may not have allowed for widescreen. So try this first, if it works, your all set. If this shows clipping, move on to the next option
* * **Widescreen Game Cheats**:  An option that modifies the game’s aspect ratio from 4:3 to 16:9 using a memory value adjustment. Sadly, this technique works only with a limited number of games, but  i  s constantly growing, so always be aware, this is STILL changing, as people are STILL finding codes to achieve this.
* * **Super Widescreen**: Enabled the widescreen hack to render at full width on the screen if the screen/window aspect radio is greater than 16:9.
* * **Horizontal Stretching**: This is exactly what is sounds like. When you have a game with a setting built in for 4:3 or 16:9, you will use this, or if you just want full screen, and none of the other methods work for that specific game, just try it out. Of course it wont increase your FOV, and things will look a little "Fatter", but many rather this then losing out on half the screen with 4:3 on a widescreen display.
* **Frame Skipping**: This option helps to speed up games for certain hardware not able to run games at full speeds. This allows you to pick how many frames can be skipped between rendered frames. The higher the number, the more skipping can occur, so the more dramatic the speedup, BUT, the more obvious that it is happening. Since using a value of 1 on 60fps games makes them run at 30fps, with 2 the speed limits to 15-20fps and so on, you should only use the lowest value that gives you a solid frame rate for best image and performance as you will lower the frame rate in games consistently, which is the difference between this and the next option...
*  * **Automatic Frame Skipping**: :You got 3 options here. One is when your CPU is getting to its limits, one is when your CPU or GPU is getting to its limits. Use this option when you are suffering from inconstant framerates, or are suffering from slowdowns. Options are Disabled, Normal and Maximum. Normal skips frames if both CPU and GPU are having slowdown, while Maximum skips frames if the GPU is having slowdown.
* **Shadows**: Enable modifier volumes; usually used for shadows. (Sometimes can be some special effects or images in game, has a very tiny performance hit, best to leave on just about all the time)
* **Fog**: Enable or disable fog effects. (Sometimes can be some special effects or images in game, has a very tiny performance hit, best to leave on just about all the time)
* **VSync**: Synchronizes the frame rate of the game with the screen refresh rate. Might add a tiny amount of input delay and performance drops in low-end machines, but gets rid of tearing on-screen (artifacts with fast scrolling graphics) and is recommended when playing online.
* **Duplicate frames**: Makes duplicate frames on monitors above 120Hz refresh rate.

* **Graphics API**: You can select between the OpenGL renderer, the DirectX renderer and the Vulkan renderer. (on windows, other distros may not have all these due to software/hardware limitations.)
* **Internal Resolution**: Manages the resolution of your game. A higher resolution will make the game more clear and sharp, but the higer your resolution the harder your GPU and CPU will be working, so if you notice framerate dips, or lowered gameplay speed, this is usually the easiest settings to adjust, come down until you get smooth gameplay. The scale goes from 426×240 (.5x) with 7680×4320 (x9) being the highest if your GPU can support it. Going above your screen resolution is possible as it can be used for Supersampling your games, but after 3x or 4x, you WILL get diminishing returns. 

* * **(NOTE FOR OBS USERS:** *If your desktop is in a smaller resolution then the internal resolution set in flycast,(eg. screens 1080P, but you set flycast to render in 1440p) you will always only capture the display resolutions size, so make sure, if your trying to get the absolute best image for your videos/streams, set your desktop resolution to 4k, even thou your monitor is 1080, then when using OBS, you will capture any benifits from having the internal resolution set to the screens max set resolution.)*
* **Aniostropic filtering**: What is ...annieareyouokay....Filtering, and what does it do? Well, here's a brief summery, so you understand what the setting does, so you can better test what option is best for you.

*Textures are two-dimensional images that fit over the surface of a three-dimensional object. They can add color, detail, and the impression of depth to a game when placed over in-game geometry (e.g. any in-game 3D objects that are viewable on-screen) or the user interface (e.g. a “heads-up display” of health bars, quick items, and so on). Anisotropic filtering modifies the appearance of the texture to account for viewing angle. As a general rule, enabling anisotropic filtering makes games look sharper with a relatively low performance cost. "OK...but what does it actually do?" Anisotropic filtering improves the appearance of textures viewed at oblique angles, rather than straight-on. That might sound abstract, but the onscreen impact can be dramatic. Distant points on the surface of a cobblestone road, for example, can look blurry in-game without texture filtering. That’s because game engines use lower-quality substitutes for textures that take up small amounts of onscreen space, like cobblestones sitting a long way down the road, or MIPMAPPING. These rendering techniques cause artifacts and distortions of perspective that can be fixed with anisotropic filtering. When filtering is turned on, the textures are modified to match the player’s viewing angle, creating a more defined vanishing point and a crisper appearance for objects farther from the “camera.” Unlike older filtering techniques, which treat textures as if they are perpendicular to the camera, anisotropic filtering modifies the textures to account for perspective.*

**"OK, So that is cool and all, I now understand this option, but when do i use it?"**

*Configuring anisotropic filtering isn’t a simple on/off choice. Settings let you decide whether to set a value of Off, x2, x4, x8, or x16. These values change the sample rate. When set to x4, anisotropic filtering collects four samples per Texel to decide the texture’s appearance. (A “Texel,” or texture element, is the smallest unit within a texture map.) A value of x16, taking 16 samples, provides the greatest benefit to textures viewed at the steepest angles. The improvement from 8x to 16x anisotropic filtering can be slight. Its visual impact can also vary greatly in different games. Though you may see diminishing returns with higher sample rates, it’s always worth testing x16 filtering to test whether you can detect the difference or notice an FPS drop.*

* *  **TL;DR** ***Set to 16x and if you have no performance issues, leave and move on.***

###  Texture Filtering: 
 **We got three options here.** Really, unless you want to have a bunch of wierd GFX issues, there is only one option but here it goes.**
* * **Default -** This is the games default, many times is a mix of nearest neighbor and the bilinear, which is the only option that wont cause issues in games, but there are pros and cons to using the other 2 options. 
* * **Nearest neighbor** - This method sorts pixels into the nearest place relevant to its placement in the original resolution, in order to display the image at whatever resolution you specify. It is very fast. At integer values (eg, exactly double or quadruple resolution) it's practically "unfiltered". Unfiltered pixels tend to look odd, with some being thicker than others. This can result in pixel art losing clarity, and text may become hard to read, and your image will have a much "Sharper" image, which can show the low resolution artifacts worse.
* * **Bilinear** - This linear filtering method uses color data from the pixels in a nearest-neighbor texture, and combines multiple bits of color data in order to replace some of the pixels with an averaged-out version of the colors, so that the colors gradually switch rather than jump to a new color. Looks better than nearest neighbor for 3D games, giving a "smoother" image. At low resolutions, 2D games tend to become TO blurry at times. This is especially noticeable in 2D games, and 3D games with many real low res textures. Is more resource intensive then Nearest Neighbor.

**"SO, WHAT ONE DO I USE?!"**

Welp, That is up to you, the game, your display, and your personal choice. I personally usually use Default, but I do always test it out for just about every game, especially with the High ResolutionTexture Packs, but give it a try, and just watch the screen and pick the best one for that specific game. 

*BE AWARE, forcing one or the other, can make graphic glitches. So Default is the recommended way to go here.*

* * **TL;DR *Default should always be used. It means the game chooses the texture filtering mode for each texture. Other options force one filtering and glitches will occur***

### Texture Upscaling:

Sharpens textures in the game, making them look better, IF done right. xBRZ is a modified version of xBR, which was built for NES (Pixel Art) era games. It is designed to smooth out the blocky pixelated appearance of these textures. It was so good, it was reworked in to xBRZ for textures over 10x10, and using what I am about to tell you, is an easy way to boost the image quality to a degree, but only if you have some Extra power on your device, because odds are your in a high resolution at this point, and upscaling textures, CAN be difficult to do, but ill show you how to get a image upgrade, on lower end devices and higher end devices. First, we need a picture, to show the differences with an image... lets see what we can find.
![](https://preview.redd.it/everything-you-need-to-know-about-flycast-emulation-the-v0-uqyvbpc0epsc1.png?width=985&format=png&auto=webp&s=e9e491ba37edd6dc13ea4d9f8fdea3e9d18f1d1d)

 This a GREAT example of all three options here in Flycast, notice that in Flycast, you can pick to force NN, or BF, but it is not recommended, this is just a great way to show the image rendered using both methods, then upscaled with xBRZ

* * **Max Threads**: This is an easy one. How many CPU threads will you allow to be used by the upscaling. The rule of thumb here, is take the number of CORES your system has, and subtract one (6 core 12 thread CPU would use the setting "5" here)

* * **Texture Upscaling**: This is how many times you multiple the textures original size. It is NOT fact that the higher this number the better the image. I will keep this short, because i need to explain...

* * **Max Texture Size:** This is the max size of the textures that get upscaled. So setting this to 10, means all textures that have a resolution of 10x10 or smaller, will be upscaled as many times as you selected in Texture Upscaling..
So, here is where things can vary wildly. Lets say your playing a game, with a lot of low res textures...
We will go two different, MAIN routes from here,
* * **Fix the Lowest quality images more**: This is one way to go, and in my opinion this end of the scale is the better way to go. What we are going to do here is take and only upscale the lowest quality resolution images more, so we don't exceed the power limit of our device. The most common sizes seen in the DC textures are 8x8, 16x16, 32x32, 64x64, 128x128, and 256x256. So depending on how much extra horsepower our device has, try setting the upscale to 4-6x (IMO the best amount) and starting at 24x24, and if your FPS dips bump that down a tad. This will NOT change everything on your screen, far from it actually, You are3 grabbing small textures with these resolutions. The higher the resolution you selected to upscale, the more items it will actually effect. Just remember, xBRZ was not meant for high res images.
* * **Fix more of the image, with less alteration**: Now, depending on the game I am playing and how it looks, I might go one way or the other, but I am somewhere on the scale, but some games, might benefit from upscaling some of its larger textures as well. So pushing up to 64, or 128 or you can even try for 265, and only using 2x or 3x multiplier, will help the higher res textures, which will look very "Mushy" if "Over Upscaled" so its a tinker on a per game basis, but personally I would usually start around64x64, and go up and down the scale. remember, there is not "Random Resolutions" They follow this scale, they are all square/rectangle, so there can be 32x64, and 8x32 but the resolutions are all set 
 We have a lower end device that we can do SOME upscaling, but not to much... so do we want to give more parts of what we see on the screen a smaller bump in quality, or do we want to take less objects on the screen, and make those look a greater deal better. A good rule of thumb, is you NEVER want to use ANY setting on a texture over like 256x256, and even that, is a rare occasion that you will get a real "benefit". The way this works, I want you to think of a game as 2 parts, a Skeleton, and Skin. You may have noticed you have seen cheat codes for games in the past that allow "WIRE FRAME MODE". This is the same thing, and shows you the game with out the "skin" or "Textures" When we talk about upscaling, we are NOT changing the skeleton; the Wire Frame, or the 3D models, that make up the physical shape and structure of what you are seeing in the game. The "Skin" part, or the Textures, are individual images, "painted" on the Skeletons, or the Models. NOW, back to the upscaling.
* * **TL;DR *The resolution limit should start low, never going over 256, but using these steps, pick the max resolution of textures to be upscaled, then set the threads to one less then how many cores your CPU has, and start at 2x and work your way up till desired effect/performance limit is met. I HIGHLY recommend, if your wanting to make your DC games look the best they can, read the above section, so you understand what your doing, and will be able to dial it in MUCH better.***



*These numbers are not just guesses. I am very fluent in what a dreamcast texture dump looks like. I know the big resolutions used, so my numbers, are set around the Commonly used sizes, to make sure you groupe them together properly for best image quality, control, and performance.*